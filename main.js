// ASINCRONIA Y PROMESAS

// SETTIMEOUT
// ES UNA FUNCION QUE PERMITE REALIZAR ACCIONES ASINCRONICAMENTE. LA FUNCION RECIBE DOS PARAMETROS: UNA FUNCION DE CALLBACK Y UN VALOR NUMERICO QUE REPRESENTA MILISEGUNDOS. 

// ASI LA FUNCION QUE PASAMOS POR PRIMER PARAMETRO SE EJECUTA LUEGO DE TRANSCURRA EL TIEMPO DEFINIDO EN EL SEGUNDO PARAMETRO. 

/*
setTimeout( () => {
    console.log('Proceso terminado')
},3000)
*/

// CALL STACK (PILA)

// ES UNA LISTA DONDE SE APILAN LAS DISTINTAS TAREAS A EJECUTAR POR NUESTRO PROGRAMA. JS ES UN LENGUAJE SINGLE THREADED, O DE UN UNICO HILO, LO QUE SIGNIFICA QUE TIENE UN UNICO STACK O PILA DE EJECUCION. DE AHI QUE LA EJECUCION ES IMPLICITAMENTE SINCRONICA. 

// PROCESO DE CALL STACK
// CUANDO SE ESTA A PUNTO DE EJECUTAR UNA FUNCION, ESTA ES AÃ‘ADIDA AL STACK. SI LA FUNCION LLAMA A LA VEZ A OTRA FUNCION ESTA ES AGREGADA SOBRE LA ANTERIOR. 

// EVENT LOOP

// MUCHAS FUNCIONES ASINCRONICAS SE EJECUTAN EN UN STACK DIFERENTE. EL EVENT LOOP ES LA HERRAMIENTA QUE PERMITE LA SINCRONIZACION ENTRE NUESTRO CALL STACK CON ESTAS TAREAS ASINCRONICAS QUE FUNCIONAN EN UN TREAD AAPRTE. SI EL STACK ESTA VACIO, EL EVENT LOOP ENVIA LA PRIMERA FUNCION QUE ESTE EN LA CALLBACK QUEUE AL CALL STACK Y COMIENZA A EJECUTARSE. 

// SETINTERVAL
// TIENE LA MISMA SINTAXIS QUE SETTIMEOUT, PERO LA UNIDAD DE TIEMPO ES UN INTERVALO PARA LA REPETICION DE LA FUNCION ASOCIADA. 

/*
setInterval (() => {
    console.log('Tic')
},1000)
*/

//CLEARINTERVAL & CLEARTIMEOUT
// EN CASO DE QUERER REMOVER UN INTERVALO, UTILIZAMOS LA FUNCION clearInterval(). TAMBIEN PODEMOS DETENER LA EJECUCION DE UN setTimeOut INVOCANDO clearTimeout()

// CUANDO LLAMAMOS UN setInterval ESTE RETORNA UNA REFERENCIA AL INTERVALO GENERADO, EL CUAL PODEMOS ALMACENAR EN UNA VARIABLE. ES ESTA REFERENCIA LA QUE DEBEMOS PASAR A LA FUNCION clearInterval PARA QUE LA LIMPIEZA TENGA EFECTO. 

/*
let counter = 0;

const interval = setInterval(() => {

    counter++
    console.log('Counter: ',counter)

    if(counter >= 5){
        clearInterval(interval)
        console.log('Se removio el intervalo')
    }
},1000)
*/

// FUNCIONA IGUAL CON LOS SETTIMEOUT. SI GUARDAMOS EN UNA VARIABLE LA REFERENCIA AL TIMEOUT GENERADO, PODEMOS USARLA PARA REMOVERLO LUEGO. EN EL SIG CASO, EL TIMEOUT GENERADO NUNCA LLEGA A EJECUTARSE.

/*
console.log('Inicio')

const fin = setTimeout(() => {
    console.log('Fin')
},2000)

clearTimeout(fin);
*/

// PROMESAS


